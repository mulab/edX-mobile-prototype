<h3>Overview</h3>
You have been assigned to improve the database performance  of a new version of the Rotten Potatoes site.

<h3>Setup:</h3>
<p>
Clone the app from: <a href="https://github.com/saasbook/hw6_rottenpotatoes">https://github.com/saasbook/hw6_rottenpotatoes</a><br/>

Now run:
<pre>bundle install --without production
rake db:create
rake db:migrate
and
rake db:seed
</pre>
The seed command may take a while as it generates roughly 5000 database entries. If the seed command is taking too long, consider lowering the amount of data that it creates by changing the following lines of <code>db/seeds.rb</code>:

<pre>movie_count=250
review_count=20
</pre>
</p>
This version of the app has some changes:
<ul><li>Review and Moviegoer models have been added.<br/>

    Take a look at the model files in <code>/app/models/</code> to get a better understanding of the relationship between the models.  Note that:
    <ul><li> Movie has many <code>Reviews</code>.</li><li><code>Movie</code> has many <code>Moviegoers</code> through <code>Reviews</code>.</li><li><code>Moviegoer</code> has many <code>Reviews</code>.</li><li><code>Moviegoer</code> has many <code>Movies</code> through <code>Reviews</code>.</li></ul>
  </li><li>New features for users in various stages of completion:<br/>

    <b>Implemented:</b><ul><li>A user can now view the average score for a film. Handled by <code>Moviescontroller#score</code></li><li>A user can now view all films reviewed by the reviewers of a given film. Handled by <code>Moviescontroller#viewed_with</code></li></ul>
    <b>Planned:</b><ul><li>A user should be able to see all of a <code>Moviegoer</code>'s <code>Reviews</code></li></ul>
    This will involve a query that looks like <code>moviegoer.reviews</code>
  </li></ul>




Unfortunately, the way that the prototype database is set up will prevent these great new features from scaling very well. As the number of <code>Reviews</code> grows, the performance will drop significantly.<br/><br/>

To help you document the performance of the queries the designer has added a benchmarking action that will provide a very rough estimate of query performance.

You can get an approximate idea of how long some sample queries take for a small data set by starting up the server and then visiting:
<pre>http://localhost:3000/benchmark/movies</pre><br/>
or
<pre>http://localhost:3000/benchmark/moviegoers</pre>
Take a look at the code in  <code>app/controller/moviescontroller.rb</code>  to see how the preceding commands work.
There are a few things to take note of:
<ul><li>These times are approximations, there is significant overhead caused by loading ActiveRecord objects, so the time spent executing queries is not the same as the time displayed on the page.</li><li>The database may not contain enough movies for these to show significant improvements after you apply migrations to improve the query performance.</li><li>If you wish to see the time spent running database queries, look at the terminal running the rails server and look for a line that looks like:
  <pre>Completed 200 OK in 423ms (Views: 8.0ms | ActiveRecord: 200.0ms)</pre><br/>
  The time after ActiveRecord is a better approximation of the actual query time.</li></ul>


A more qualitative method to evaluate performance is to look at what your database's query planner will use to execute the queries.
If you are running the virtual machine you can do this by running commands:
<pre>
cd db
sqlite3 development.sqlite3
</pre><br/>
you should see a prompt that looks like:
<pre>sqlite&gt;</pre>
If you want to see the plan that sqlite3 expects to use, along with its estimation of the number of rows that it will look through, run:
<pre>EXPLAIN QUERY PLAN &lt;query&gt;;</pre>
with &lt;query&gt; replaced by the query you want to investigate.
The score action uses
<pre>@movie.reviews</pre>
this gets translated to the query:
<pre>SELECT "reviews".* FROM "reviews" WHERE "reviews"."movie_id" = 1;</pre>
putting this all together you can see the estimated number of rows viewed by typing in:
<pre>explain query plan SELECT "reviews".* FROM "reviews" WHERE "reviews"."movie_id" = 1;</pre>
You will get a result that looks like:
<pre>SCAN TABLE reviews (~# rows)</pre>
The number of rows is an approximation, but it is useful for comparing performance between different schema.
The skeleton code performs a Table Scan to execute this query. This is one of the reasons that the current implementation will lose performance as the amount of <code>Reviews</code> grows.<br/><br/>
<h3>Requirements</h3><br/>

Your task is to add a migration, or migrations that will improve the performance by eliminate the use of table scans for the following two queries:

<pre>moviegoer.reviews</pre>
and
<pre>movie.reviews</pre>

<b>Note:</b> In the previous two queries, <code>moviegoer</code> and <code>movie</code> are instances of the <code>Moviegoer</code> and <code>Movie</code> models.
<b>Note:</b> This should not require very much code, in fact adding 2 indices is enough to prevent table scans from occurring for these queries.
<br/><br/>
To easily create a migration run the following command:
<pre> rails generate migration migrationName</pre>

To read more about migrations visit: <a href="http://guides.rubyonrails.org/migrations.html">http://guides.rubyonrails.org/migrations.html</a>
After you have added your migrations, make sure to run <pre>rake db:migrate</pre> to make sure they get applied to the database.

Check your results either by using <code>sqlite3</code>, or the <code>benchmark</code> action to see if you are getting better results. If you use the benchmark action It may be necessary to add more <code>Reviews</code> to make this noticeable.You can modify <code>db/seeds.rb</code> to do so.  

A successful change should  eliminate table scans for both of the queries.
